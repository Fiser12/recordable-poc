---
description: 
globs: 
alwaysApply: true
---
# **02: Arquitectura del Proyecto (React Native & Expo)**

## **Introducción**

Esta sección detalla la arquitectura de software seleccionada para el proyecto, transitando desde los requisitos funcionales y no funcionales definidos hacia una solución técnica concreta basada en React Native y Expo. El objetivo es establecer una estructura clara, mantenible y escalable que facilite el desarrollo y la evolución de la aplicación móvil.

## **1\. Transición del Análisis al Diseño**

El paso del análisis (el *qué*) al diseño (el *cómo*) implica tomar decisiones sobre la estructura interna de la aplicación, las tecnologías específicas dentro del ecosistema React Native/Expo, y cómo se organizarán los componentes para cumplir con los requisitos. Se priorizará la eficiencia, la experiencia de usuario nativa, la seguridad y la mantenibilidad, aprovechando las capacidades de Expo para simplificar el desarrollo y despliegue.

## **2\. Diseño Arquitectónico General**

Se adopta una arquitectura por capas y basada en componentes, un enfoque común y efectivo en React Native.

*   **Capas Principales:**
    *   **Presentación (UI):** Compuesta por componentes React Native (funcionales y utilizando Hooks), responsables de renderizar la interfaz de usuario y capturar las interacciones del usuario. Se utilizará `StyleSheet` de React Native para los estilos, buscando la reutilización y consistencia.
    *   **Lógica de Negocio/Dominio (State Management & Hooks):** Contendrá la lógica de la aplicación, el manejo del estado (posiblemente con Zustand, Context API o Redux Toolkit, según la complejidad) y hooks personalizados para encapsular lógica reutilizable.
    *   **Datos/Servicios:** Responsable de la comunicación con APIs externas (backend), almacenamiento local (ej. AsyncStorage) y cualquier otra fuente de datos. Se definirán servicios o adaptadores claros para encapsular estas operaciones.
*   **Navegación:** Se utilizará `React Navigation` para gestionar las distintas pantallas y flujos de navegación dentro de la aplicación.
*   **Estructura de Directorios:** Se definirá una estructura de carpetas modular (por ejemplo, por *feature* o por tipo de archivo: `components`, `screens`, `hooks`, `services`, `navigation`, `store`, `assets`, `constants`, `utils`) para organizar el código de manera lógica.

## **3\. Diseño Detallado**

*   **Componentes React Native:** Se favorecerá la creación de componentes funcionales y el uso extensivo de Hooks (`useState`, `useEffect`, `useContext`, etc.). Se buscará la creación de componentes reutilizables y bien definidos (presentacionales vs. contenedores si aplica).
*   **Manejo de Estado:** La elección de la librería de manejo de estado (Zustand, Context API, Redux Toolkit) se basará en la complejidad de la compartición de estado requerida. Se buscará un manejo de estado predecible y fácil de depurar.
*   **Interacción con APIs:** Se definirán funciones o clases de servicio claras para interactuar con el backend, utilizando `fetch` o librerías como `axios`. Se manejarán adecuadamente los estados de carga, éxito y error.
*   **Estilos:** Uso de `StyleSheet.create` para optimización. Se definirán temas o constantes de estilo para mantener la consistencia visual.
*   **Módulos Nativos:** Si se requiere funcionalidad nativa no cubierta por Expo o React Native, se evaluará la necesidad de *ejectuar* de Expo o usar módulos de la comunidad compatibles con Expo Dev Client.

## **4\. Aplicación de Patrones de Diseño**

Se aplicarán patrones relevantes en el contexto de React/React Native:

*   **Component-Based Architecture:** Fundamental en React.
*   **Hooks:** Para encapsular lógica con estado y efectos secundarios reutilizables.
*   **Context API:** Para inyección de dependencias o manejo de estado global simple/moderado (puede considerarse una forma de *Service Locator* o *Dependency Injection*).
*   **State Management Patterns:** Según la librería elegida (ej. Reducer pattern con `useReducer` o Redux).
*   **Container/Presentational Components:** Aunque menos estricto con Hooks, la separación de responsabilidades sigue siendo un principio útil.
*   **Patrones para manejo asíncrono:** Uso de `async/await`, manejo de promesas y patrones para gestionar estados de carga/error en llamadas a APIs.
*   **Servicios/Adaptadores:** Para desacoplar la lógica de la aplicación del acceso a datos (similar a *DAO* o *Gateway* pero adaptado al frontend).
*   **DTO (Data Transfer Object):** Implícitamente, al definir las estructuras de datos esperadas de las APIs.

Esta arquitectura busca equilibrar la flexibilidad con la estructura, permitiendo un desarrollo eficiente y la creación de una aplicación robusta con React Native y Expo. 